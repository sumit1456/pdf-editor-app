        # 3. Process each modification SURGICALLY
        for p_idx, mods in mods_by_page.items():
            page = doc[p_idx]
            text_dict = page.get_text("dict")
            applied_mod_ids = set()

            # A. First, try to match modifications to existing text lines in the PDF
            for block in text_dict.get("blocks", []):
                if block["type"] == 0: # Text
                    for line in block["lines"]:
                        target_mod = None
                        line_match = False
                        
                        # Use 1.5px tolerance for sniper-matching
                        for s_orig in line["spans"]:
                            ox, oy = s_orig["origin"][0] * PT_TO_PX, s_orig["origin"][1] * PT_TO_PX
                            for m in mods:
                                if m.type != "pdf_path" and m.id not in applied_mod_ids:
                                    if abs(m.origin[0] - ox) < 1.5 and abs(m.origin[1] - oy) < 1.5:
                                        target_mod = m
                                        applied_mod_ids.add(m.id)
                                        line_match = True
                                        break
                            if line_match: break

                        if target_mod:
                            # 1. Redact ONLY the line we are replacing
                            page.add_redact_annot(line["bbox"], fill=(1,1,1))
                            page.apply_redactions()

                            # 2. Render the new text exactly where requested
                            line_spans = target_mod.spans if (target_mod.spans and len(target_mod.spans) > 0) else [
                                TextSpan(
                                    text=target_mod.text or "",
                                    font=target_mod.style.get("font"),
                                    size=target_mod.style.get("size"),
                                    color=target_mod.style.get("color"),
                                    is_bold=target_mod.style.get("is_bold"),
                                    is_italic=target_mod.style.get("is_italic"),
                                    font_variant=target_mod.style.get("font_variant", "normal")
                                )
                            ]
                            
                            curr_x, curr_y = [coord / PT_TO_PX for coord in target_mod.origin]
                            for span in line_spans:
                                s_text = span.text
                                s_font_in = (span.font or "inter").lower()
                                s_is_bold = span.is_bold
                                s_is_italic = span.is_italic
                                s_variant = span.font_variant or "normal"
                                s_size = (span.size or 10) / PT_TO_PX
                                s_color = span.color or [0, 0, 0]

                                for sym, rep in SYMBOL_MAP.items():
                                    s_text = s_text.replace(sym, rep)

                                font_path, font_key = font_manager.get_font_path(s_font_in, s_is_bold, s_is_italic)
                                if font_path:
                                    try:
                                        internal_name = f"f-{font_key.lower()}"
                                        temp_font = fitz.Font(fontfile=font_path)
                                        if s_variant == "small-caps":
                                            for char in s_text:
                                                is_lower_alpha = char.islower() and char.isalpha()
                                                c_size = s_size * (0.75 if is_lower_alpha else 1.0)
                                                c_char = char.upper() if is_lower_alpha else char
                                                page.insert_text((curr_x, curr_y), c_char, fontsize=c_size, color=tuple(s_color), fontfile=font_path, fontname=internal_name)
                                                curr_x += temp_font.text_length(c_char, fontsize=c_size)
                                        else:
                                            page.insert_text((curr_x, curr_y), s_text, fontsize=s_size, color=tuple(s_color), fontfile=font_path, fontname=internal_name)
                                            curr_x += temp_font.text_length(s_text, fontsize=s_size)
                                    except: pass
                            
                            if target_mod.uri:
                                page.insert_link({"from": fitz.Rect(target_mod.bbox) / PT_TO_PX, "uri": target_mod.uri, "kind": fitz.LINK_URI})

            # B. Handle Remaining Mods (New text or vector drawings)
            for m in mods:
                if m.id in applied_mod_ids: continue
                
                if m.type == "pdf_path" and m.path_data:
                    shape = page.new_shape()
                    for p in m.path_data:
                        if "fill_color" in p:
                            fc = p["fill_color"]
                            shape.draw_rect(fitz.Rect(p["pts"][0]) / PT_TO_PX)
                            shape.finish(fill=tuple(fc), fill_opacity=p.get("fill_opacity", 1.0), stroke_opacity=0)
                        if "stroke_color" in p:
                            sc = p["stroke_color"]
                            for segment in p["segments"]:
                                if segment["type"] == "m":
                                    shape.move_to(fitz.Point(segment["x"], segment["y"]) / PT_TO_PX)
                                elif segment["type"] == "l":
                                    pts = segment["pts"]
                                    if len(pts) >= 2:
                                        shape.line_to(fitz.Point(pts[1]) / PT_TO_PX)
                            shape.finish(color=tuple(sc), width=p.get("stroke_width", 1.0)/PT_TO_PX, stroke_opacity=p.get("stroke_opacity", 1.0))
                    shape.commit()
                
                elif m.text:
                    curr_x, curr_y = [coord / PT_TO_PX for coord in m.origin]
                    s_font_in = (m.style.get("font") or "inter").lower()
                    s_is_bold = m.style.get("is_bold")
                    s_is_italic = m.style.get("is_italic")
                    s_size = (m.style.get("size") or 10) / PT_TO_PX
                    s_color = m.style.get("color") or [0, 0, 0]

                    font_path, font_key = font_manager.get_font_path(s_font_in, s_is_bold, s_is_italic)
                    if font_path:
                        try:
                            internal_name = f"f-{font_key.lower()}"
                            page.insert_text((curr_x, curr_y), m.text, fontsize=s_size, color=tuple(s_color), fontfile=font_path, fontname=internal_name)
                        except: pass

        # 4. Save to memory and return
        out_pdf_buffer = io.BytesIO()
        doc.save(out_pdf_buffer)
        doc.close()
        
        out_pdf_b64 = base64.b64encode(out_pdf_buffer.getvalue()).decode('utf-8')
        
        return {
            "success": True,
            "pdf_base64": out_pdf_b64,
            "filename": f"edited_{request.pdf_name}"
        }
